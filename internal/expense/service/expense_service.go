package service

import (
	"errors"
	"fmt"
	"slices"
	"time"

	"github.com/SalmandaAK/expense-tracker/internal/expense/domain"
)

var errInvalidMonth = errors.New("month should be between 1 and 12 inclusively")

type ExpenseService struct {
	r domain.ExpenseRepository
}

func New(r domain.ExpenseRepository) *ExpenseService {
	return &ExpenseService{
		r: r,
	}
}

func (s *ExpenseService) AddExpense(description string, amount int) (int, error) {
	// Expense Id will be generated by repository
	e := &domain.Expense{
		Description: description,
		Amount:      amount,
		CreatedAt:   time.Now(),
	}
	err := s.r.AddExpense(e)
	if err != nil {
		return 0, err
	}
	return int(e.Id), nil
}

func (s *ExpenseService) FindAllExpenses() ([]*domain.Expense, error) {
	expenses, err := s.r.FindAllExpenses()
	if err != nil {
		return nil, err
	}
	return expenses, nil
}

func (s *ExpenseService) DeleteExpense(id int) error {
	e, err := s.r.FindExpenseById(domain.ExpenseId(id))
	if err != nil {
		return err
	}
	err = s.r.DeleteExpense(e)
	if err != nil {
		return err
	}
	return nil
}

func (s *ExpenseService) SummaryExpenses() (int, error) {
	expenses, err := s.r.FindAllExpenses()
	if err != nil {
		return 0, err
	}
	var sum int
	iter := slices.Values(expenses)
	for expense := range iter {
		sum += expense.Amount
	}
	return sum, nil
}

func (s *ExpenseService) SummaryExpensesByMonth(month int) (int, error) {
	if month < 1 || month > 12 {
		return 0, errInvalidMonth
	}
	expenses, err := s.r.FindAllExpensesByMonth(month)
	if err != nil {
		return 0, fmt.Errorf("%v: %v", err, time.Month(month).String())
	}
	var sum int
	iter := slices.Values(expenses)
	for expense := range iter {
		sum += expense.Amount
	}
	return sum, nil
}
